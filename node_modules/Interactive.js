module.exports = (function (){
	const T=require("ThreadManager.js");
	const Interactive = new Object();
	const registered = new Object();
	const interactiveQueue = new java.util.concurrent.LinkedBlockingQueue();
	Interactive.register = function(tag, room, sender, cmdFunc){
		if(registered[room]==undefined) registered[room] = new Object();
		if(registered[room][tag]==undefined){
			const queue = new java.util.concurrent.LinkedBlockingQueue();
			const input = {
				get : () => queue.take(),
				getMsg : () => queue.take().msg
			}
			const thread = T.register("interactive_"+room+"_"+tag, function(){
				try{
					cmdFunc(input);
				}catch(e){
				}finally{
					delete registered[room][tag];
				}
			})
			registered[room][tag] = {
				sender : sender ? new Set(Array.isArray(sender) ? sender : [sender] ) : null,
				queue : queue,
				thread : thread
			}
			thread.start();
			return true;
		}else{
			return false;
		}
	};
	Interactive.register.toString = () => 'Interactive.register(tag, room, sender, func(input))\n'
		+ '대화형 명령어를 등록합니다.\n'
		+ '"tag"는 수행할 대화형 명령어의 tag를 의미합니다. 같은 tag가 이미 등록되어 있을 때는 추가로 실행되지 않습니다.\n'
		+ '"room"는 대화형 명령어를 수행할 방의 이름입니다.\n'
		+ '"sender"는 대화형 명령어 모드의 적용 대상인 사용자입니다. null일 경우 해당 방의 모든 사용자에 대하여 반응합니다. 배열일 경우 배열 요소들의 사용자들에 대하여 반응합니다.\n'
		+ '"func"는 수행할 대화형 명령어의 callback function입니다. 한가지 인수를 가집니다.\n'
		+ '   input - input.get()을 사용하면 {msg, sender}로 이루어진 객체를 얻을 수 있으며, input.getMsg()를 사용하면 바로 msg를 얻을 수 있습니다.'
//	Interactive.unregister = function(tag, room){
//			if(tag){
//				if(room){
//					registered[room][tag].thread.interrupt();
//				}else{
//					
//					
//				}
//			}
//		}
		
	Interactive.run = function(room,sender,msg){
		if(registered[room]==undefined) return false;
		else{
			const keys = Object.keys(registered[room]);
			if(keys.length>0) {
				return keys.map(v=>{
					if(registered[room][v].sender==null || registered[room][v].sender.has(sender)){
						registered[room][v].queue.put({msg:msg, sender:sender})
						return true;
					}else return false;
				}).some(v=>v);
			}
			else return false;
		}	
	}
	Interactive.run.toString = () => 'Interactive.run(room, sender, msg)\n'
		+ '등록된 대화형 명령어를 수행합니다.\n'
		+ 'response 함수 상단에 놓아서 수행하는것을 권장합니다.\n'
		+ '수행된 명령어가 있을 경우 true, 그렇지 않을 경우 false를 return합니다.'
	

	Interactive.registered = registered;
	Interactive.toString = () => 'Interactive';
	Interactive.help = () => 'Interactive\n'
		+ 'Interactive.register(tag, room, sender, func(input))\n'
		+ 'Interactive.run(room, sender, msg)\n';
	Interactive.example = () => 'const Interactive = require("Interactive.js")\n\n'
		+ 'function response(room, msg, sender, isGroupChat, replier, imageDB) {\n'
		+ '   var isRun = Interactive.run(room, sender, msg);\n'
		+ '   if(!isRun){\n'
		+ '      if(msg=="test"){\n'
		+ '         Interactive.register("test", room, sender, function(input){\n'
		+ '            replier.reply("1을 누르세요");\n'
		+ '            var a;\n'
		+ '            while(true){\n'
		+ '               a = input.getMsg();\n'
		+ '               if(a=="1"){\n'
		+ '                  replier.reply("1이 눌렸습니다. 종료합니다.");\n'
		+ '                  break;\n'
		+ '               }\n'
		+ '               else {\n'
		+ '                  replier.reply("잘못 입력되었습니다. 입력된 것은 "+a+"입니다.");\n'
		+ '               }\n'
		+ '            }\n'
		+ '         })\n'
		+ '      }\n'
		+ '   }\n'
		+ '}'
		
		
	return Interactive;
})();

Interactive = require("Interactive.js")
